#include <core.mag>
#include <headers.mag>
#include <parser.mag>
#include <defines.mag>

// learn arp by dhcp packet
processing_block learn_arp_by_dhcp(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    assert(pkt.hdr.dhcp.isValid());
    ipv4_to_mac[pkt.hdr.dhcp.assignedAddr] = pkt.hdr.dhcp.clientMacAddr;
}

// learn arp by arp packet
processing_block learn_arp_by_arp(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    ipv4_to_mac[pkt.hdr.arp.ipSrcAddr] = pkt.hdr.arp.macSrcAddr;
}

// arp response
processing_block response_arp(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    assert(pkt.hdr.arp.isValid());
    assert(pkt.hdr.arp.opcode = ARP_REQUEST;

    // build arp response
    pkt.hdr.arp.macSrcAddr = ipv4_to_mac[pkt.hdr.arp.ipDstAddr];
    swap(pkt.hdr.arp.ipSrcAddr, pkt.hdr.arp.ipDstAddr);
    pkt.hdr.arp.macDstAddr = pkt.hdr.arp.macSrcAddr;
    pkt.hdr.arp.opcode = ARP_RESPONSE;
}

// swap the MAC addresses
processing_block reflect_l2(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    swap(pkt.hdr.ethernet.srcAddr, pkt.hdr.ethernet.dstAddr);
}

// decrease ttl
processing_block dec_ttl(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    assert(pkt.hdr.ipv4.isValid());
    assert(pkt.hdr.ipv4.ttl > 0);
    pkt.hdr.ipv4.ttl--;
}

// rewrite dest mac
processing_block rewrite_mac(inout packet_t<headers_t, metadata_t> pkt, in tm_t tm) {
    assert(pkt.hdr.ipv4.isValid());
    pkt.hdr.ethernet.dstAddr = ipv4_to_mac[pkt.hdr.ipv4.dst];
}

path_control l3_forwarding(inout packet_t<headers_t> pkt) {
    try {
        pkt.egress_path = shortest_path(pkt.ingress_swport, ip_to_swport[pkt.hdr.ipv4.dst]);
        pkt.processing_rule = dec_ttl*, (dec_ttl & rewrite_mac);
    } catch(INVALID_KEY e) {
        pkt.egress_path = drop;
    }
}

path_control arp(inout packet_t<headers_t, metadata_t> pkt) {
    try {
        pkt.egress_path = shortest_path(pkt.ingress_swport, ip_to_swport[pkt.hdr.arp.ipSrcAddr]);
        pkt.processing_rule = (learn_arp_by_arp & response_arp), .*;
    } catch(INVALID_KEY e) {
        pkt.egress_path = spanning_tree(pkt.ingress_swport);
        pkt.processing_rule = learn_arp_by_arp, .*;
    }
}

path_control dhcp(inout packet_t<headers_t> pkt) {
    try {
        if (pkt.hdr.dhcp.op == DHCP_REQUEST) { // dhcp request
            pkt.egress_path = spanning_tree(pkt.ingress_swport);  // broadcast to dhcp servers
            pkt.processing_rule = dec_ttl*
        } else { // dhcp response
            pkt.egress_path = shortest_path(pkt.ingress_swport, mac_to_swport[pkt.hdr.dhcp.clientMacAddr]);
            pkt.processing_rule = (learn_arp_by_dhcp & dec_ttl), dec_ttl*;
        }
    } catch(INVALID_KEY e) {
        pkt.egress_path = drop;
    }
}

program {
    'external_ingress' => {
        parser=MyParser,
        path_control=(l3_forwarding | arp | dhcp)
    }
}
















/*
easy to program:
1. map/set/list high level structures.
2. auto derive configs











// route builder
path_control pc(inout packet_t<headers_t, metadata_t> pkt) {
    handle_arp_pc(pkt);
    handle_dhcp_pc(pkt);
    handle_l3_forwarding_pc(pkt);


    if (pkt.hdr.arp.isValid()) { // arp
        try {
            if !(pkt.hdr.arp.ipDstAddr in ipv4_to_mac) { // arp not learned
                throw 'mac unknown exception';
            }
            // arp response path
            pkt.egress_path = shortest_path(pkt.ingress_swport, ip_to_swport[pkt.hdr.arp.ipSrcAddr]);
            pkt.processing_rule = (learn_arp_by_arp & response_arp), dec_ttl*;

        } catch(exception_t e) {
            if (e.reason == 'mac unknown exception') {
                // path to arp dst host
                auto path = shortest_path(pkt.ingress_swport, ip_to_swport[pkt.hdr.arp.ipDstAddr])
                pkt.egress_path = path;
                pkt.processing_rule = learn_arp_by_arp, dec_ttl*;
            }
        }
    } else if (pkt.hdr.dhcp.isValid()) {  // dhcp
        if (pkt.hdr.dhcp.op == DHCP_REQUEST) { // dhcp request
            pkt.egress_path = spanning_tree(pkt.ingress_swport);  // broadcast to dhcp servers
            pkt.processing_rule = dec_ttl*
        } else { // dhcp offer
            pkt.egress_path = shortest_path(pkt.ingress_swport, mac_to_swport[pkt.hdr.dhcp.clientMacAddr]);
            pkt.processing_rule = (learn_arp_by_dhcp & dec_ttl), dec_ttl*;
        }
    } else if (pkt.hdr.ipv4.isValid()) {  // l3 forward
        auto path = shortest_path(pkt.ingress_swport, ip_to_swport[pkt.hdr.ipv4.dst]);
        pkt.egress_path = path;
        pkt.processing_rule = dec_ttl*, (dec_ttl & rewrite_mac);
    } else {
        pkt.egress_path = drop;
    }
}

// parser/header compose

label 'external_ingress' {
    parser=MyParser,
    path_control=l3_forward & dhcp,
    //packet_processing_rule=([dec_ttl]*, [dec_ttl & rewrite_mac & handle_arp & reflect_l2 & handle_dhcp])
}






/*
TODO:
    programming model
    fboss use case
    compiler
    * incremental depoloyment
    * fault tolerance
    * scaling
    what's new/cool things can be done by magellan
    debugger api support reliablity

    completeness - arp dhcp ipv4/6 lldp
    fault tolerance, how to handle fast reroute
    scaling

non directional feedback
path_control -> tree, route_builder
fix name packet_processing_rule

requirements:
    first, second, second last, last, specific index
    once anywhere, all
    specific device(type)
    issue to think about: at least/most once, exact once










label 'external_ingress' {
    frontpipe {
        auto dst_id = ip_to_dstid.lpm(pkt.hdr.ipv4.dst)
        pkt.hdr.myTunnel.dst_id = dst_id;
        pkt.hdr.myTunnel.setValid();
        auto path = shortest_path(pkt.ingress_swport, dstid_to_swport[dst_id]);
        pkt.egress_path = fwd_action;
    }
    // ingress is ambiguous, if inst depends on ingress_swport, queue or egress_port, inst must be put at egress pipe
    transpipe {
        pkt.hdr.ipv4.ttl--;
        if (hdr.ipv4.ecn == 1 || hdr.ipv4.ecn == 2){
            if (switch_meta.enq_qdepth >= ECN_THRESHOLD){
                hdr.ipv4.ecn = 3;
            }
        }
        if (idx == pkt.egress_path.size() - 1) {
            pkt.hdr.myTunnel.setInvalid();
            pkt.hdr.ethernet.dstAddr = ipv4_to_mac[pkt.hdr.ipv4.dst];
        }
    }
}

